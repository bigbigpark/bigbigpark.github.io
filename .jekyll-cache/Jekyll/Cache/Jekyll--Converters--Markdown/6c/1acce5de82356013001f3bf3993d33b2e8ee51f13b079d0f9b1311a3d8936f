I"<p>기회는 준비된 자에게 온다 !</p>

<h2 id="시작에-앞서-시간-복잡도란">시작에 앞서… 시간 복잡도란?</h2>

<p>시간 복잡도(Time complexity)는 자료 구조나 알고리즘이 얼마나 빠르고, 느린 지 측정하는 방법이다.</p>

<p>이렇다고 해서 실제로 실행에 소요된 시간(elasped time)을 측정하는 것이 아니다.</p>

<p>바로 얼마나 많은 <strong>단계(steps)</strong>가 있는 가로 측정된다.</p>

<p>따라서 같은 일을 하더라도 적은 단계의 프로그램이 효율적이라 할 수 있다.</p>

<h2 id="메모리-관점에서의-배열이란">메모리 관점에서의 배열이란?</h2>

<p>배열을 선언할 때 메모리(통상적으로 RAM을 말함)에 <strong>배열의 길이</strong>와 <strong>어디서 시작하는 지</strong> 알려줘야 함.</p>

<h3 id="1-읽기-reading">1) 읽기 (reading)</h3>

<p>배열은 0부터 인덱싱한다.</p>

<p>따라서 배열이 메모리에서 어디에 위치해있는 지 알고 있으면 접근 속도가 굉장히 빠르다.</p>

<h3 id="2-검색-searching">2) 검색 (searching)</h3>

<p>읽기와 달리 시간이 조금 걸린다.</p>

<p>데이터를 읽을 때는 인덱스를 입력하면 되지만 검색은 다르다.</p>

<p>해당 값이 배열이 있는 지 없는 지도 모른다. 따라서 배열을 하나하나 다 뒤져야 하는 단점이 있다.</p>

<p>찾고자 하는 데이터가 배열의 제일 처음에 위치해 있으면 빨리 찾지만 최악의 경우는 제일 마지막 인덱스에 위치할 경우다.</p>

<p>=&gt; 이 때 인덱스 0부터 순서대로 검색하는 것을 <strong>선형 탐색(Linear Search)</strong>라고 함</p>

<h3 id="3-삽입-insertion">3) 삽입 (insertion)</h3>

<p>삽입의 경우 제일 최고의 경우는 배열 제일 마지막에 추가하는 것이다.</p>

<p>하지만 가운데 삽입하게 될 경우 삽입하려는 인덱스 기점 오른쪽 데이터를 모두 한칸씩 밀어야한다.</p>

<p>이 때 배열 크기를 초과하게 되면 새로운 배열을 만들고 값을 복사하는 등의 추가적인 절차로 인하여 속도가 저하될 수 있다.</p>
:ET