I"($<p>Ceres solver 사용법 정리<br /></p>

<p>이 글은 <a href="https://github.com/LimHyungTae">임형태</a>님의 <a href="https://github.com/LimHyungTae/helloceres">helloceres</a> git 코드를 기반으로 작성되었습니다 <br /></p>

<p><br /></p>

<p>Ceres solver를 사용하게 될 일이 있을 것 같아서 공부하면서 정리하면서 포스팅중이다<br /></p>

<h2 id="ceres는-어떤-문제를-푸는가">Ceres는 어떤 문제를 푸는가?</h2>

<p>기본적으로 구속 조건이 있는 비선형 최적화 문제를 풀 수 있다 <br />
ceres solver에 사용되는 기본 식의 뼈대는 아래 사진과 같다 <br /></p>

<p><img src="/assets/img/ceres/2022-04-14/01.png" alt="" /></p>

<p><br /></p>

<h2 id="example-code">Example code</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A simple example of using the Ceres minimizer.</span>
<span class="c1">//</span>
<span class="c1">// Minimize 0.5 (10 - x)^2 using jacobian matrix computed using</span>
<span class="c1">// automatic differentiation.</span>

<span class="cp">#include</span> <span class="cpf">"ceres/ceres.h"</span><span class="cp">
#include</span> <span class="cpf">"glog/logging.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">AutoDiffCostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">CostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Problem</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solver</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solve</span><span class="p">;</span>

<span class="c1">// A templated cost functor that implements the residual r = 10 -</span>
<span class="c1">// x. The method operator() is templated so that we can then use an</span>
<span class="c1">// automatic differentiation wrapper around it to generate its</span>
<span class="c1">// derivatives.</span>
<span class="k">struct</span> <span class="nc">CostFunctor</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="k">const</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">google</span><span class="o">::</span><span class="n">InitGoogleLogging</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="c1">// The variable to solve for with its initial value. It will be</span>
    <span class="c1">// mutated in place by the solver.</span>
    <span class="kt">double</span>       <span class="n">x</span>         <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">initial_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

    <span class="c1">// Build the problem.</span>
    <span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

    <span class="c1">// Set up the only cost function (also known as residual). This uses</span>
    <span class="c1">// auto-differentiation to obtain the derivative (jacobian).</span>
    <span class="n">CostFunction</span> <span class="o">*</span><span class="n">cost_function</span> <span class="o">=</span>
                         <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">CostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">CostFunctor</span><span class="p">);</span>
    <span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

    <span class="c1">// Run the solver!</span>
    <span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
    <span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
    <span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">summary</span><span class="p">.</span><span class="n">BriefReport</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x : "</span> <span class="o">&lt;&lt;</span> <span class="n">initial_x</span>
              <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="설명">설명</h2>

<h3 id="costfunctor">CostFunctor</h3>

<p><code class="language-plaintext highlighter-rouge">CostFunctor</code> 구조체 안에 residual이 선언되어 있다 <br /></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div></div>
<p>이라고 선언하면 우리가 최소화 해야하는 함수는 <br />
 \(\frac{1}{2} *(10 \, - \, x)^2\) 인 것을 알 수 있다 <br /></p>

<h3 id="costfunctionautodiffcostfunction">CostFunction/AutoDiffCostFunction</h3>

<p>위의 식에서 \(f\)에 해당하는 부분이다 <br />
cost function을 어떤 함수로 가져갈 지 선언해준다 <br />
이번 예제로는 \(f=(10-x)^2\)를</p>

<p><code class="language-plaintext highlighter-rouge">CostFunction</code> 이 부분에서 <code class="language-plaintext highlighter-rouge">AutoDiffCostFunction</code>이란 거 보니 자동으로 미분해주는? 그런 함수인 거 같은데 <code class="language-plaintext highlighter-rouge">CostFunctor</code>를 인자로
가져가는 걸 봐서 저걸 사용하겠다까지는 이해했는데, 그 뒤에 들어가는 인자인 &lt;Costfunctor, <strong>1, 1</strong>&gt; 부분은 좀 더 스터디가 필요하다 <br /></p>

<h3 id="addresidualblock">AddResidualBlock</h3>

<p>인자가 넘어가는 형태로 보아 위에서 정의했던 cost_function \(f\) 에다가 minimize하는 파라미터 x를 찾는 residual block을 추가하겠다라는 뜻 인 거 같다!<br /></p>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://github.com/LimHyungTae/helloceres">LimHyungTae/helloceres</a></li>
</ul>
:ET