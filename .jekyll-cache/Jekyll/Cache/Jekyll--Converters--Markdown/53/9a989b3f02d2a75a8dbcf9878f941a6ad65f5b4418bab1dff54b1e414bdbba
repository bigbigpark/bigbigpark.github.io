I"+<p>Ceres solver ì‚¬ìš©ë²• ì •ë¦¬<br /></p>

<p>ì´ ê¸€ì€ <a href="https://github.com/LimHyungTae">ì„í˜•íƒœ</a>ë‹˜ì˜ <a href="https://github.com/LimHyungTae/helloceres">helloceres</a> git ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤ <br /></p>

<p><br /></p>

<p>Ceres solverë¥¼ ì‚¬ìš©í•˜ê²Œ ë  ì¼ì´ ìˆì„ ê²ƒ ê°™ì•„ì„œ ê³µë¶€í•˜ë©´ì„œ ì •ë¦¬í•˜ë©´ì„œ í¬ìŠ¤íŒ…ì¤‘ì´ë‹¤<br /></p>

<h2 id="ceresëŠ”-ì–´ë–¤-ë¬¸ì œë¥¼-í‘¸ëŠ”ê°€">CeresëŠ” ì–´ë–¤ ë¬¸ì œë¥¼ í‘¸ëŠ”ê°€?</h2>

<p>ê¸°ë³¸ì ìœ¼ë¡œ êµ¬ì† ì¡°ê±´ì´ ìˆëŠ” non-linear least square ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆë‹¤ <br />
ceres solverì— ì‚¬ìš©ë˜ëŠ” ê¸°ë³¸ ì‹ì˜ ë¼ˆëŒ€ëŠ” ì•„ë˜ ì‚¬ì§„ê³¼ ê°™ë‹¤ <br /></p>

<p><img src="/assets/img/ceres/2022-04-14/01.png" alt="" /></p>

<p><br /></p>

<h2 id="example-code">Example code</h2>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A simple example of using the Ceres minimizer.</span>
<span class="c1">//</span>
<span class="c1">// Minimize 0.5 (10 - x)^2 using jacobian matrix computed using</span>
<span class="c1">// automatic differentiation.</span>

<span class="cp">#include</span> <span class="cpf">"ceres/ceres.h"</span><span class="cp">
#include</span> <span class="cpf">"glog/logging.h"</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">AutoDiffCostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">CostFunction</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Problem</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solver</span><span class="p">;</span>
<span class="k">using</span> <span class="n">ceres</span><span class="o">::</span><span class="n">Solve</span><span class="p">;</span>

<span class="c1">// A templated cost functor that implements the residual r = 10 -</span>
<span class="c1">// x. The method operator() is templated so that we can then use an</span>
<span class="c1">// automatic differentiation wrapper around it to generate its</span>
<span class="c1">// derivatives.</span>
<span class="k">struct</span> <span class="nc">CostFunctor</span> <span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">T</span> <span class="o">*</span><span class="k">const</span> <span class="n">x</span><span class="p">,</span> <span class="n">T</span> <span class="o">*</span><span class="n">residual</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">google</span><span class="o">::</span><span class="n">InitGoogleLogging</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

  <span class="c1">// The variable to solve for with its initial value.</span>
  <span class="kt">double</span> <span class="n">initial_x</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="n">initial_x</span><span class="p">;</span>

  <span class="c1">// Build the problem.</span>
  <span class="n">Problem</span> <span class="n">problem</span><span class="p">;</span>

  <span class="c1">// Set up the only cost function (also known as residual). This uses</span>
  <span class="c1">// auto-differentiation to obtain the derivative (jacobian).</span>
  <span class="n">CostFunction</span><span class="o">*</span> <span class="n">cost_function</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">AutoDiffCostFunction</span><span class="o">&lt;</span><span class="n">CostFunctor</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">CostFunctor</span><span class="p">);</span>
  <span class="n">problem</span><span class="p">.</span><span class="n">AddResidualBlock</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>

  <span class="c1">// Run the solver!</span>
  <span class="n">Solver</span><span class="o">::</span><span class="n">Options</span> <span class="n">options</span><span class="p">;</span>
  <span class="n">options</span><span class="p">.</span><span class="n">linear_solver_type</span> <span class="o">=</span> <span class="n">ceres</span><span class="o">::</span><span class="n">DENSE_QR</span><span class="p">;</span>
  <span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">Solver</span><span class="o">::</span><span class="n">Summary</span> <span class="n">summary</span><span class="p">;</span>
  <span class="n">Solve</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">problem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">summary</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">summary</span><span class="p">.</span><span class="n">BriefReport</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"x : "</span> <span class="o">&lt;&lt;</span> <span class="n">initial_x</span>
            <span class="o">&lt;&lt;</span> <span class="s">" -&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="ì„¤ëª…">ì„¤ëª…</h2>

<h3 id="costfunctor">CostFunctor</h3>

<p><code class="language-plaintext highlighter-rouge">CostFunctor</code> êµ¬ì¡°ì²´ ì•ˆì— residualì´ ì„ ì–¸ë˜ì–´ ìˆë‹¤ <br /></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</code></pre></div></div>
<p>ì´ë¼ê³  ì„ ì–¸í•˜ë©´ ìš°ë¦¬ê°€ ìµœì†Œí™” í•´ì•¼í•˜ëŠ” í•¨ìˆ˜ëŠ” <br />
 \(\frac{1}{2} *(10 \, - \, x)^2\) ì¸ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤ <br /></p>

<h3 id="costfunctionautodiffcostfunction">CostFunction/AutoDiffCostFunction</h3>

<p>ìœ„ì˜ ì‹ì—ì„œ \(f\)ì— í•´ë‹¹í•˜ëŠ” ë¶€ë¶„ì´ë‹¤ <br />
cost functionì„ ì–´ë–¤ í•¨ìˆ˜ë¡œ ê°€ì ¸ê°ˆ ì§€ ì„ ì–¸í•´ì¤€ë‹¤ <br />
ì´ë²ˆ ì˜ˆì œë¡œëŠ” \(f=(10-x)^2\) ì´ ë˜ê² ë‹¤ <br /></p>

<p><code class="language-plaintext highlighter-rouge">AutoDiffCostFunction</code>ì´ë€ ê±° ë³´ë‹ˆ ìë™ìœ¼ë¡œ ë¯¸ë¶„í•´ì£¼ëŠ”? ê·¸ëŸ° í•¨ìˆ˜ì¸ ê±° ê°™ì€ë° <code class="language-plaintext highlighter-rouge">CostFunctor</code>ë¥¼ ì¸ìë¡œ
ê°€ì ¸ê°€ëŠ” ê±¸ ë´ì„œ ì €ê±¸ ì‚¬ìš©í•˜ê² ë‹¤ê¹Œì§€ëŠ” ì´í•´í–ˆëŠ”ë°, ê·¸ ë’¤ì— ë“¤ì–´ê°€ëŠ” ìˆ«ì ì¸ììì¸ &lt;Costfunctor, <strong>1, 1</strong>&gt; ë¶€ë¶„ì€ ì¢€ ë” ìŠ¤í„°ë””ê°€ í•„ìš”í•˜ë‹¤ <br /></p>

<h3 id="addresidualblock">AddResidualBlock</h3>

<p>ì¸ìê°€ ë„˜ì–´ê°€ëŠ” í˜•íƒœë¡œ ë³´ì•„ ìœ„ì—ì„œ ì •ì˜í–ˆë˜ cost_function \(f\) ë¥¼ ìµœì†Œí™” í•˜ëŠ” íŒŒë¼ë¯¸í„° \(x\)ë¥¼ ì°¾ì•„ì•¼ í•˜ë‹ˆê¹Œ ê·¸ëŸ° residual block í•˜ë‚˜ë¥¼ ì¶”ê°€í•˜ê² ë‹¤ë¼ëŠ” ëœ» ì¸ ê±° ê°™ë‹¤!<br /></p>

<h3 id="solver">Solver</h3>

<p>solverë¥¼ ì„ ì–¸í•˜ê¸° ì „ì— <code class="language-plaintext highlighter-rouge">options</code>ë¥¼ ë¨¼ì € ì„ ì–¸í•´ì£¼ê³ , solverì˜ optionë“¤ì„ ë„£ì–´ì¤€ë‹¤ <br /></p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">options</span><span class="p">.</span><span class="n">minimizer_progress_to_stdout</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</code></pre></div></div>
<p>ëŠ” ìµœì†Œí™” í•˜ëŠ” ê³¼ì •ì„ ì¶œë ¥í•  ì§€ ë§ ì§€ ê²°ì •í•˜ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ì¶”ì •ëœë‹¤. <br /></p>

<p><code class="language-plaintext highlighter-rouge">Solver()</code>í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ë¬¸ì œë¥¼ í’€ì–´ì¤€ë‹¤ <br /></p>
<ul>
  <li>ìš°ë¦¬ê°€ residual block í•˜ë‚˜ë¥¼ ë„£ì—ˆë˜ problem</li>
  <li>ë°©ê¸ˆ ì •ì˜í•œ solverì˜ option</li>
  <li>ìµœì†Œí™” ê³¼ì •ì„ ìš”ì•½í•œ summary
ì´ ì„¸ ì¸ìë¥¼ ë„˜ê²¨ì£¼ê³  ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆê²Œ ëœë‹¤ <br /></li>
</ul>

<h2 id="ê²°ê³¼">ê²°ê³¼</h2>

<p>\(f=(10-x)^2\) ì´ì—ˆìœ¼ë¯€ë¡œ ìš°ë¦¬ëŠ” ì†ìœ¼ë¡œë„ \(x=10\)ì„ êµ¬í•  ìˆ˜ ìˆê³ , <br />
ceres solver ê²°ê³¼ë„ <strong>ë™ì¼</strong>í•¨ì„ í™•ì¸í–ˆë‹¤ <br /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time
   0  1.250000e+01    0.00e+00    5.00e+00   0.00e+00   0.00e+00  1.00e+04        0    4.98e-05    1.13e-04
   1  1.249750e-07    1.25e+01    5.00e-04   5.00e+00   1.00e+00  3.00e+04        1    7.61e-05    3.02e-04
   2  1.388518e-16    1.25e-07    1.67e-08   5.00e-04   1.00e+00  9.00e+04        1    1.79e-05    3.43e-04
Ceres Solver Report: Iterations: 3, Initial cost: 1.250000e+01, Final cost: 1.388518e-16, Termination: CONVERGENCE
x : 5 -&gt; 10
</code></pre></div></div>

<h2 id="reference">Reference</h2>
<ul>
  <li><a href="https://github.com/LimHyungTae/helloceres">LimHyungTae/helloceres</a></li>
</ul>
:ET