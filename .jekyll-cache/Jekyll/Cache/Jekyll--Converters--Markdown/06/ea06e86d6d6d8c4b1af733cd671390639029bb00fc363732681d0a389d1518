I"	<p>기회는 준비된 자에게 온다 !</p>

<h2 id="시간-복잡도의-정의">시간 복잡도의 정의</h2>

<p>시간 복잡도(Time Complexity)란 알고리즘이 문제를 해결하기 위한 <strong>연산</strong>의 횟수다.</p>

<p>알고리즘을 평가할 때 2가지의 척도가 사용된다.</p>

<ul>
  <li><strong>Time Complexity</strong>: 수행 연산에 대항하는 <strong>시간 복잡도</strong></li>
  <li><strong>Space Complexity</strong>: 메모리 사용량에 해당하는 <strong>공간 복잡도</strong></li>
</ul>

<p>복잡도니까 낮을 수록 효율적인 알고리즘이겠지? 라는 생각을 해본다.</p>

<p>이를 정량적으로 표현하기 위해 빅오 표기법을 사용한다.</p>

<h2 id="빅오-표기법이란">빅오 표기법이란</h2>

<p>시간 복잡도의 경우 빅오(Big-O)로 표현한다.</p>

<p>통상 연산 횟수를 카운팅 할 때는 3가지를 사용한다.</p>

<ul>
  <li><strong>Best Case</strong>: 최선의 경우 -&gt; Big-Ω [빅-오메가]</li>
  <li><strong>Worst Case</strong>: 최악의 경우 -&gt; <strong>Big-O [빅-오]</strong></li>
  <li><strong>Average Case</strong>: 평균의 경우 -&gt;Big-θ [빅-세타]</li>
</ul>

<p>따라서 빅오 표기법이란 <strong>최악의 경우</strong>를 고려하여, 프로그램이 실행되는 과정에서 소요된 연산 횟수를 카운팅한다.</p>

<centor> 

|      빅오 표기법      | 표현      |
| :-------------------: | --------- |
|   $$\mathbf{O}(1)$$   | 상수      |
| $$\mathbf{O}(logN)$$  | 로그      |
|   $$\mathbf{O}(N)$$   | 선형      |
| $$\mathbf{O}(NlogN)$$ | 로그 선형 |
|  $$\mathbf{O}(N^2)$$  | 다항      |
|  $$\mathbf{O}(2^n)$$  | 지수      |

![](/assets/img/data_structure/2022-12-09/Selection_0000.png)

&lt;/center&gt;

## Reference

* [[자료구조] 연결 리스트(Linked List) 개념과 구현](https://leejinseop.tistory.com/4)
* [연결 리스트(Linked list) 개념정리](https://lamarr.dev/datastructure/2020/04/02/01-linked-list.html)
* [[자료구조] 배열 리스트와 연결 리스트의 차이 (장단점)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=tjsrudv&amp;logNo=221055137174)

* [[Data Structure] C++ / 자료구조 / Linked list](https://velog.io/@kon6443/Data-Structure-C-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Linked-list)
* [[C++ STL] list(연결리스트)](https://sanghyu.tistory.com/84)
</centor>
:ET