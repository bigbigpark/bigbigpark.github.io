I"Y<p>기회는 준비된 자에게 온다 !</p>

<h2 id="해시의-정의">해시의 정의</h2>

<p>해시(Hash) 구조란 무엇일까?</p>

<p><strong>키(key)</strong>와 <strong>값(value)</strong>의 쌍으로 이루어진 데이터 구조를 일컫는다.</p>

<p>파이썬으로 치면 dictionary라는데 C++을 주로 사용해본 나로서는 직관적으로 와닿지 않는다.</p>

<p><br /></p>

<p><strong>해시</strong>라는 자료구조 이름이 있는 것이 아니라, 정확히 해시라고 하는 것은 임의의 값을 고정 길이로 변환하는 작업을 뜻한다.</p>

<p>아래 사진으로 좀 더 정리한다.</p>

<h2 id="해시와-관련된-몇-가지-용어">해시와 관련된 몇 가지 용어</h2>

<p><img src="/assets/img/data_structure/2022-12-09/Selection_0002.png" alt="" /></p>

<ul>
  <li>키 (Key) : 해시 함수(Hash Function)의 input이 되는 고유한 값</li>
  <li>해시 (Hash) : 임의의 값을 고정 길이로 변환하는 것</li>
  <li>해시 테이블 (Hash Table) : key 값의 연산에 의해 직접 접근이 가능한 데이터 구조</li>
  <li>버킷 (Bucket) 또는 슬롯 (Slot) : 해시 테이블에서 하나의 데이터가 저장되는 공간</li>
  <li>해시 함수 (Hashing Function) : key 값에 대해 연산을 통해 데이터(value)의 위치를 찾는 함수</li>
</ul>

<p><br /></p>

<p>그림에서 <code class="language-plaintext highlighter-rouge">school</code>, <code class="language-plaintext highlighter-rouge">office</code>, <code class="language-plaintext highlighter-rouge">house</code> 같은 입력 값이 들어왔을 때 해쉬 함수를 이용해서 정수값으로 변환하여 버킷에 저장한 것을 볼 수 있다.</p>

<p>이 과정을 다른 말로 해싱(Hashing)이라고 부르기도 한다.</p>

<p>따라서 입력 데이터(key)와 변환된 정수 값(value)의 쌍으로 저장하는 자료 구조를 <strong>해시 테이블(Hash Table)</strong>이라고 부른다.</p>

<p>파이썬 딕셔너리 예제를 들고 왔는데, 해시 테이블은 아래와 같이 사용된다고 볼 수 있다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">person_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s">'name'</span> <span class="p">:</span> <span class="s">'bigbigpark'</span><span class="p">,</span> <span class="s">'height'</span> <span class="p">:</span> <span class="mi">178</span><span class="p">,</span> <span class="s">'weight'</span> <span class="p">:</span> <span class="mi">75</span><span class="p">}</span>
</code></pre></div></div>

<p>이 때 왼쪽에 있는 것이 key 값인데, 인덱스로 검색하는 것이 아닌 키값으로 O(1)로 자료 읽기가 가능하다.</p>

<h2 id="해시-테이블의-기능">해시 테이블의 기능</h2>

<p>뒤에 설명할 <strong>해시 충돌(Hash Collision)</strong>이 없다는 가정하에,</p>

<ul>
  <li>데이터 삽입
    <ul>
      <li>key값을 hash function을 이용하여 hash로 변경</li>
      <li>미리 준비해둔 저장소(bucket, slot) 중 알맞는 hash 값을 찾아 value를 저장</li>
      <li>삽입 과정의 시간 복잡도는 O(1)</li>
    </ul>
  </li>
  <li>데이터 삭제
    <ul>
      <li>buncket에서 삭제하려고 하는 key와 매칭이 되는 value를 찾아 삭제함</li>
      <li>삭제 과정의 시간 복잡도는 O(1)</li>
    </ul>
  </li>
  <li>데이터 검색
    <ul>
      <li>key값을 hash function을 이용하여 hash를 찾고 해당 value 검색 가능</li>
      <li>검색 과정의 시간 복잡도는 O(1)</li>
    </ul>
  </li>
</ul>

<h2 id="해시-테이블의-장단점">해시 테이블의 장단점</h2>

<p>해시 테이블은 <strong>데이터 검색, 삽입, 삭제</strong>가 많이 필요한 경우에 자주 사용된다.</p>

<p>하지만 hash 값들을 저장할 공간(bucket)을 지정해야 하므로 일반적으로 <strong>많은 저장 공간이 요구</strong>된다.</p>

<p>또 여러 key에 해당하는 hash(주소 개념)이 동일한 경우 해시 충돌(Hash Collision)이 발생한다.</p>

<h2 id="해시-충돌">해시 충돌</h2>

<p>해시 충돌이란 위에서 언급되었듯 여러 key에 의한 중복된 해시에 의해서 나타난다.</p>

<p>사실 비둘기집의 원리에 의해 해시기반 자료구조에서는 불가피한 일이다.</p>

<p><img src="/assets/img/data_structure/2022-12-09/Selection_0003.png" alt="" /></p>

<p>위의 사진에서 H(x)는 해시 함수를 말한다. 일반적인 경우 해시 함수를 곱셈법 혹은 나눗셈법을 이용하여 정의하기도 한다. 그림에 있듯이 나머지 연산으로 정의 하게 되면 List=[11, 12, 13, 14, 15, 21, 22, 23, 24, 25]일 때 충돌이 불가피한 것을 예상할 수 있다.</p>

<h2 id="해시-충돌의-해결">해시 충돌의 해결</h2>

<h3 id="1-chaining">1) Chaining</h3>

<p>연결 리스트 기반 Chaining 방법을 이용해서 해시 충돌 문제를 해결할 수 있다.</p>

<p>Chaining 방법은 hash 함수의 결과 값인 동일한 bucket에 저장하되 원래 저장되어 있던 value의 next로 연결하는 형태로 저장하는 방법을 말한다.</p>

<p>직관적으로 충돌 해결을 할 수 있지만 검색 연산에 있어 연결 리스트를 처음부터 하나씩 찾아야 하므로 최악의 경우 시간 복잡도가 O(n)까지 증가할 수 있다는 단점이 있다.</p>

<h3 id="2-open-addressing">2) Open Addressing</h3>

<p>다른 말로 close hashing, linear probing이라고 부르기도 한다.</p>

<p>이 방법은 충돌이 일어날 경우, 비어있는 hash를 찾아 데이터를 저장하는 기법이다.</p>

<p>따라서 chaining 기법은 하나의 hash에 여러 value들이 저장된 구조인 반면, open addressing 에서는 무조건적으로 key-value는 1:1 매칭이 된다.</p>

<p><br /></p>

<p>이 때 충돌이 일어나는 hash 기준 양옆 한칸씩 보며 빈 공간을 찾아가는 기법을 <strong>linear probing</strong>이라고 하는데, 이 기법은 특정 위치에만 밀집하는 clustering 문제가 발생할 수 있다.</p>

<p>따라서 <strong>n^2</strong>으로 이동하며 빈 공간을 찾아가는 <strong>quadratic probing</strong> 기법도 존재한다.</p>

<h3 id="3-double-hasing">3) Double Hasing</h3>

<p>해시 충돌이 발생할 경우 또 다른 해시 함수를 사용하여 증가 폭을 구한다. 증가폭만큼 인덱스를 증가시키며 비어있는 곳을 탐색하는 방법이다.</p>

<h3 id="3-해시-함수-개선">3) 해시 함수 개선</h3>

<p>다양한 해시 함수가 있고, 변형도 너무 많다. 그 중 일반적으로 사용되는 것 중에 나눗셈법이 존재한다.</p>

<ul>
  <li>나눗셈법
    <ul>
      <li>이 방법은 미리 해시 테이블의 크기 N을 아는 경우에 사용 가능하다.</li>
      <li>H(x) = x mod N</li>
      <li>이 때 N은 2의 k제곱 꼴을 사용하면 안 된다. 왜냐하면 하위 k비트를 고려하지 않기 때문이다.</li>
      <li>결국… 소수가 짱인가?</li>
    </ul>
  </li>
</ul>

<h2 id="해시-함수-언제-쓰는데">해시 함수 언제 쓰는데?</h2>

<ul>
  <li>전화번호부
    <ul>
      <li>핸드폰 연락처를 생각했을 때, 저장할 때는 사람의 이름+관련 전화번호를 추가한다.</li>
      <li>추후 <strong>이름</strong>만 검색해도 저장된 이름 및 전화번호에 대한 정보를 준다.</li>
    </ul>
  </li>
  <li>메뉴판
    <ul>
      <li>메뉴 이름과 가격을 추가한다.</li>
      <li>추후 <strong>메뉴 이름</strong>만 검색을 하면 메뉴와 가격을 알려주는 메뉴판도 만들 수 있다.</li>
    </ul>
  </li>
  <li>중복된 항목 방지
    <ul>
      <li>투표소에서 누가누가 투표를 했는 지 안 했는지 판단하기 위해서 사용될 수 있다.</li>
      <li>배열이나 리스트를 사용하게 되면 O(N)이 소요되기 때문이다.</li>
      <li>입력에 <strong>이름</strong>을 입력했을 때 해시 테이블에 이름이 있는 지 없는 지 바로 알 수 있다.</li>
    </ul>
  </li>
</ul>

<h2 id="해시-테이블-함수-기능">해시 테이블 함수 기능</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">insert(std::pair&lt;first,second&gt;)</code>
    <ul>
      <li>key-value 쌍을 해시 테이블에 삽입한다.</li>
      <li>이 때 이미 등록된 key가 있다면 무시된다. ([ ] 인덱스로 덮어쓰기 가능)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">erase(key)</code>
    <ul>
      <li>key를 해시 테이블에서 삭제한다.</li>
      <li>key를 찾지 못하면 제일 끝 반복자인 <code class="language-plaintext highlighter-rouge">end()</code>를 호출한다</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">count(key)</code>
    <ul>
      <li>key 값에 해당하는 원소들의 개수 리턴</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">size()</code>
    <ul>
      <li>해시 테이블에 저장된 key-value 쌍의 개수 리턴</li>
    </ul>
  </li>
</ul>

<h2 id="해시-테이블-사용-예시-c-stl">해시 테이블 사용 예시 (C++, STL)</h2>

<p>C++의 STL에서는 대표적인 해시 맵이 두 가지 있다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">std::map</code>
    <ul>
      <li>tree 기반으로 구현된다</li>
      <li>key를 기준으로 <strong>오름차순으로 자동 정렬</strong></li>
      <li>시간복잡도 O(log N)</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">std::unordered_map</code>
    <ul>
      <li>hash 기반으로 구현된다</li>
      <li>특별한 정렬 절차가 없다</li>
      <li>시간 복잡도 O(1)</li>
    </ul>
  </li>
</ul>

<p>사실 원소의 순서가 중요하지 않을 때 사용하는 해시 테이블 자료 구조 특성상 <code class="language-plaintext highlighter-rouge">std::map</code>은 필요 없는듯.</p>

<p>그리고.. <strong>중복된 원소는 insert 시 무시된다</strong> ㅠ</p>

<p><br /></p>

<h3 id="기본-선언">기본 선언</h3>

<p>아래 <code class="language-plaintext highlighter-rouge">&lt;unordered_map&gt;</code>을 인클루드 해주고 main 함수에서 아래와 같이 사용할 수 있다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash_table</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="사용법">사용법</h3>

<p>반드시 해시 테이블에 선언했던 자료형 쌍으로 입력해주자.</p>

<p><code class="language-plaintext highlighter-rouge">make_pair&lt;first, second&gt;</code>를 이용하면 쉽게 insert할 수 있다.</p>

<p>이 때 중복을 허락하지 않는다. 따라서 제일 처음에 넣은 “Eric”-27 만 해시 테이블에 매핑된다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 삽입</span>
<span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">27</span><span class="p">));</span>
<span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Amanda"</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
<span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">100</span><span class="p">));</span>
</code></pre></div></div>

<p><br /></p>

<p>하지만 아래와 같이 강제로 덮어쓰기 할 수 있다.</p>

<p>이 경우 “Eric”이 해시 테이블에 없다면 새로 추가하는 경우가 생기니… 반드시 <code class="language-plaintext highlighter-rouge">find()</code>로 검사하는 프로세스를 추가하자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hash_table</span><span class="p">[</span><span class="s">"Eric"</span><span class="p">]</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 삭제, 키가 없을 시 end() 반환</span>
<span class="n">hash_table</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"Amanda"</span><span class="p">);</span>

<span class="c1">// 출력</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">iter</span> <span class="o">:</span> <span class="n">hash_table</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="중복-가능-해시-테이블-사용-예시-c-stl">중복 가능 해시 테이블 사용 예시 (C++, STL)</h2>

<p>앞서 봤던 <code class="language-plaintext highlighter-rouge">&lt;unordered_map&gt;</code>은 insert 동작 시 중복을 무시하였다.</p>

<p>하지만 <code class="language-plaintext highlighter-rouge">multimap</code>을 이용하여 중복 가능한 해시 테이블 예시로 사용할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">&lt;map&gt;</code> 안에 포함되어 있다.</p>

<h3 id="기본-선언-및-삽입">기본 선언 및 삽입</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hash_table</span><span class="p">;</span>

  <span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">);</span>
  <span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="p">);</span>
  <span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="p">);</span>
  <span class="n">hash_table</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">"Eric"</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span> <span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hash_table</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"Eric"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이 문장 빌드가 안 될 것이다.</span>
<span class="c1">// 어떤 것을 반환해야할 지 몰라서</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">hash_table</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="s">"Eric"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="검색">검색</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// equal_range는 중복된 해시 값에 대한 첫 번째 반복자(first)와 두 번째 반복자 (second)를</span>
<span class="c1">// std::pair 형태로 반환한다.</span>
<span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">hash_table</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="s">"Eric"</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">iter</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" : "</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="내가-만든-구조체를-이용한-해시-테이블을-만들고-싶을-때">내가 만든 구조체를 이용한 해시 테이블을 만들고 싶을 때</h2>

<p>아쉽지만… 해시 함수를 직접 구현하는 수 밖에 없다.</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://ai-rtistic.com/2022/01/29/data-structure-hash/">자료구조(Data Structure) 톺아보기 - 해시(Hash)</a></li>
  <li>[<a href="https://ablue-1.tistory.com/68">[자료구조] 해시(Hash)란 무엇인가](https://ablue-1.tistory.com/68)</a></li>
  <li>
    <p>[<a href="https://baeharam.github.io/posts/data-structure/hash-table/">[자료구조] 해시 테이블(Hash Table)](https://baeharam.github.io/posts/data-structure/hash-table/)</a></p>
  </li>
  <li>
    <p><a href="https://www.geeksforgeeks.org/hashing-data-structure/">Hashing Data Structure</a></p>
  </li>
  <li><a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">Hash Table</a>만</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[[C++] 해시맵(Hashmap)을 이해해보자</td>
          <td>std::unordered_map</td>
          <td>기술면접](https://woo-dev.tistory.com/106)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li><a href="https://ansohxxn.github.io/stl/map/">[STL 컨테이너] map &amp; unordered_map &amp; multimap</a></li>
</ul>
:ET